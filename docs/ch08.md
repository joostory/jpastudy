
# 8.1 프록시
```kotlin
@Entity
class Member(
  @Id
  @Column(name = "ID")
  var id: String? = null,
  @Column(name = "NAME")
  var username: String = ""
) {
  @ManyToOne
  @JoinColumn(name = "TEAM_ID", referencedColumnName = "ID")
  var team: Team? = null
}

@Entity
class Team(
  @Id
  @Column(name = "ID")
  var id: String? = null,
  @Column(name = "NAME")
  var name: String = "",
)
```

```kotlin
private fun printUserAndTeam(em: EntityManager) {
  val member = em.find(Member::class.java, 1L)
  val team = member.team
  log("회원이름: ${member.username}")
  log("팀이름: ${team?.name}")
}

private fun printUser(em: EntityManager) {
  val member = em.find(Member::class.java, 1L)
  log("회원이름: ${member.username}")
}
```

printUser는 member.team을 사용하지 않으므로 DB에서 조회하는 것은 효율적이지 않다.
JPA에서 엔티티가 실제 사용될때까지 조회를 지연하는 방법을 제공하는데 이를 지연로딩이라 한다.
지연로딩을 위해서 실제 엔티티 객체가 아닌 가짜객체가 필요한데 이를 프록시 객체라고 한다.

## 8.1.1 프록시 기초
```kotlin
val member = em.find(Member::class.java, 1L) // DB 조회, 엔티티 객체 생성
val member = em.getReference(Member::class.java, 1L) // 프록시 객체 반환
```
- 사용자는 구분하지 않고 사용
- 프록시 객체는 실제객체에 대한 참조를 보관
- 프록시 객체 메소드를 호출하면 실제 객체의 메소드를 호출

### 프록시 객체의 초기화
```kotlin
val member = em.getReference(Member::class.java, 1L)
log("회원이름: ${member.username}") // 1. getName

class MemberProxy(): Member {
  var target: Member? = null
  var name: String
    get() {
      if (target == null) {
          // 2. 초기화 요청
          // 3. DB 조회
          // 4. 실제 엔티티 생성 및 참조 보관
          target = ...
      }
      return target.name // 5. target.getName
    }
}
```

### 프록시의 특징
- 프록시 객체는 처음 사용할때 한번만 초기화
- 초기화한다고 프록시객체가 엔티티로 바뀌는 것이 아니다. 계속 프록시를 통해 엔티티에 접근한다.
- 프록시 객체는 엔티티를 상속받은 객체이므로 타입체크시 고려해야한다.
- 영속성 컨텍스트에 엔티티가 이미 있으면 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 한다. 따라서 준영속 상태의 프록시를 초기화하면 예외를 발생한다.

## 8.1.2 프록시와 식별자
프록시를 조회할때 식별자를 사용한다. 따라서 프록시 객체는 식별자를 보관한다.
```kotlin
val member = em.getReference(Member::class.java, 1L)
log("회원id: ${member.id}") // 초기화 안됨
```
위 경우 초기화하지 않으나 엔티티 접근방식을 프로퍼티로 설정한 경우만 초기화 하지 않는다.
엔티티 접근방식을 필드로 설정하면 getId가 다른 필드를 활용하는지 알지 못하므로 프록시 객체를 초기화 한다.

```kotlin
private fun referenceMember(em: EntityManager) {
  val member = em.find(Member::class.java, 2L)
  val team = em.getReference(Team::class.java, 4L)
  member.team = team
}
```
연관관계를 설정할때는 AccessType.FIELD를 설정해도 초기화하지 않는다. (kotlin에서 테스트해보니 하더라)

## 8.1.3 프록시 확인
```kotlin
val team = em.getReference(Team::class.java, 4L)
log("isLoaded = ${em.entityManagerFactory.persistenceUnitUtil.isLoaded(team)}")
log("proxy = ${team.javaClass.name}")
```
persistenceUnitUtil.isLoaded로 초기화여부를 알 수 있고 클래스명으로 프록시 여부를 알 수 있다.
하지만 kotlin에서는 위 코드는 아래와 같은 답을 준다.
```
Hibernate: 
    select
        team0_.ID as id1_1_0_,
        team0_.NAME as name2_1_0_ 
    from
        ch08Team team0_ 
    where
        team0_.ID=?
[DEBUG] isLoaded = true
[DEBUG] proxy = net.joostory.jpastudy.ch08.Team
```

```java
  private void referenceTeam() {
    Member2 member = em.find(Member2.class, 1L);
    Team2 team = em.getReference(Team2.class, 2L);
    System.out.println("team=" + team.getId());
    System.out.println("team=" + em.getEntityManagerFactory().getPersistenceUnitUtil().isLoaded(team));
    System.out.println("team=" + team.getClass().getName());
    member.setTeam(team);
  }
```
Java에서는 기대한대로 동작한다. 클래스명에는 `$HibernateProxy$`가 붙는다.
```
team=2
team=false
team=net.joostory.jpastudy.ch08.Team2$HibernateProxy$AYERQN4F
```

# 8.2 즉시 로딩과 지연 로딩
# 8.3 지연 로딩 활용
# 8.4 영속성 전이: CASCADE
# 8.5 고아객체
# 8.6 영속성 전이 + 고아객체, 생명주기
